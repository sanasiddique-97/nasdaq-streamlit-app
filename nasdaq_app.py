{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "86342dfb-1a28-4a98-b256-edb7beca863a",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "2025-09-21 16:43:06.252 No runtime found, using MemoryCacheStorageManager\n",
      "2025-09-21 16:43:06.284 No runtime found, using MemoryCacheStorageManager\n"
     ]
    }
   ],
   "source": [
    "import streamlit as st\n",
    "import pandas as pd\n",
    "import requests\n",
    "import yfinance as yf\n",
    "import datetime\n",
    "import io\n",
    "\n",
    "# ==================== Load NASDAQ Tickers ====================\n",
    "\n",
    "@st.cache_data(show_spinner=False)\n",
    "def load_nasdaq_tickers():\n",
    "    \"\"\"Load full NASDAQ-listed tickers from official source.\"\"\"\n",
    "    url = \"https://www.nasdaqtrader.com/dynamic/symdir/nasdaqlisted.txt\"\n",
    "    resp = requests.get(url)\n",
    "    resp.raise_for_status()\n",
    "    df = pd.read_csv(\n",
    "        io.StringIO(resp.text),\n",
    "        sep=\"|\",\n",
    "        skipfooter=1,\n",
    "        engine=\"python\"\n",
    "    )\n",
    "    df = df[df[\"Test Issue\"] == \"N\"]  # remove test tickers\n",
    "    return df[[\"Symbol\", \"Security Name\"]].reset_index(drop=True)\n",
    "\n",
    "@st.cache_data(show_spinner=False)\n",
    "def get_metadata(tickers):\n",
    "    \"\"\"Fetch sector, industry, and market cap for a list of tickers.\"\"\"\n",
    "    data = []\n",
    "    for t in tickers:\n",
    "        try:\n",
    "            info = yf.Ticker(t).info\n",
    "            data.append({\n",
    "                \"Symbol\": t,\n",
    "                \"Sector\": info.get(\"sector\", \"Unknown\"),\n",
    "                \"Industry\": info.get(\"industry\", \"Unknown\"),\n",
    "                \"Market Cap\": info.get(\"marketCap\", None)\n",
    "            })\n",
    "        except Exception:\n",
    "            data.append({\"Symbol\": t, \"Sector\": \"Unknown\", \"Industry\": \"Unknown\", \"Market Cap\": None})\n",
    "    return pd.DataFrame(data)\n",
    "\n",
    "# ==================== Stock Data ====================\n",
    "\n",
    "def download_data(tickers, period=\"3mo\", interval=\"1d\"):\n",
    "    df = yf.download(tickers, period=period, interval=interval, group_by=\"ticker\", auto_adjust=False)\n",
    "    if isinstance(tickers, list) and len(tickers) > 1:\n",
    "        if \"Adj Close\" in df.columns.levels[0]:\n",
    "            df = df[\"Adj Close\"]\n",
    "        else:\n",
    "            df = df[\"Close\"]\n",
    "    else:\n",
    "        if \"Adj Close\" in df.columns:\n",
    "            df = df[[\"Adj Close\"]]\n",
    "        elif \"Close\" in df.columns:\n",
    "            df = df[[\"Close\"]]\n",
    "        else:\n",
    "            raise KeyError(\"Neither 'Adj Close' nor 'Close' found in data.\")\n",
    "        ticker_name = tickers if isinstance(tickers, str) else tickers[0]\n",
    "        df.columns = [ticker_name]\n",
    "    return df\n",
    "\n",
    "def compare_stock(df, base_ticker, start_date=None, end_date=None):\n",
    "    data = df.copy()\n",
    "    if start_date and end_date:\n",
    "        data = data.loc[start_date:end_date]\n",
    "    pct_change = data.pct_change().fillna(0)\n",
    "    cumulative = (1 + pct_change).cumprod()\n",
    "    if base_ticker not in cumulative.columns:\n",
    "        st.error(f\"{base_ticker} not found in tickers list.\")\n",
    "        return None, []\n",
    "    base_perf = cumulative[base_ticker]\n",
    "    comparison = cumulative.divide(base_perf, axis=0)\n",
    "    outperformers = comparison.iloc[-1][comparison.iloc[-1] > 1].index.tolist()\n",
    "    return comparison, outperformers\n",
    "\n",
    "# ==================== Streamlit UI ====================\n",
    "\n",
    "def main():\n",
    "    st.title(\"ðŸ“ˆ NASDAQ Stock Comparison Tool with Filters\")\n",
    "    st.write(\"Compare any NASDAQ stock against others, filtered by **sector, industry, or market cap**.\")\n",
    "\n",
    "    # Load ticker list\n",
    "    nasdaq_df = load_nasdaq_tickers()\n",
    "    symbols = nasdaq_df[\"Symbol\"].tolist()\n",
    "\n",
    "    # Sidebar inputs\n",
    "    st.sidebar.header(\"Filter Stocks\")\n",
    "\n",
    "    # Base stock choice\n",
    "    base_ticker = st.sidebar.selectbox(\"Base Stock (symbol)\", symbols, index=0)\n",
    "\n",
    "    # Fetch metadata for filtering\n",
    "    st.write(\"ðŸ”„ Fetching metadata (sector, industry, market cap)...\")\n",
    "    meta_df = get_metadata(symbols[:300])  # limit for speed\n",
    "\n",
    "    # Filtering options\n",
    "    sector_options = sorted(meta_df[\"Sector\"].dropna().unique().tolist())\n",
    "    selected_sector = st.sidebar.multiselect(\"Filter by Sector\", sector_options)\n",
    "\n",
    "    industry_options = sorted(meta_df[\"Industry\"].dropna().unique().tolist())\n",
    "    selected_industry = st.sidebar.multiselect(\"Filter by Industry\", industry_options)\n",
    "\n",
    "    marketcap_min = st.sidebar.number_input(\"Minimum Market Cap (USD)\", value=1_000_000_000, step=100_000_000)\n",
    "\n",
    "    # Apply filters\n",
    "    filtered = meta_df.copy()\n",
    "    if selected_sector:\n",
    "        filtered = filtered[filtered[\"Sector\"].isin(selected_sector)]\n",
    "    if selected_industry:\n",
    "        filtered = filtered[filtered[\"Industry\"].isin(selected_industry)]\n",
    "    if marketcap_min > 0:\n",
    "        filtered = filtered[filtered[\"Market Cap\"].fillna(0) >= marketcap_min]\n",
    "\n",
    "    comparison_symbols = filtered[\"Symbol\"].tolist()\n",
    "\n",
    "    # Always include base ticker\n",
    "    if base_ticker not in comparison_symbols:\n",
    "        comparison_symbols.append(base_ticker)\n",
    "\n",
    "    st.write(f\"âœ… {len(comparison_symbols)} stocks selected for comparison\")\n",
    "\n",
    "    # Date inputs\n",
    "    start_date = st.sidebar.date_input(\"Start Date\", datetime.date.today() - datetime.timedelta(days=90))\n",
    "    end_date = st.sidebar.date_input(\"End Date\", datetime.date.today())\n",
    "    interval = st.sidebar.radio(\"Interval\", [\"1d\", \"1wk\"], index=0)\n",
    "\n",
    "    # Run analysis\n",
    "    if st.sidebar.button(\"Compare\"):\n",
    "        df_prices = download_data(comparison_symbols, period=\"6mo\", interval=interval)\n",
    "        comparison_df, outperformers = compare_stock(df_prices, base_ticker, str(start_date), str(end_date))\n",
    "        if comparison_df is not None:\n",
    "            st.subheader(f\"Stocks that outperformed {base_ticker} ({start_date} â†’ {end_date})\")\n",
    "            if outperformers:\n",
    "                st.success(\", \".join(outperformers))\n",
    "            else:\n",
    "                st.warning(\"No stocks outperformed in that range.\")\n",
    "            st.line_chart(comparison_df)\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
